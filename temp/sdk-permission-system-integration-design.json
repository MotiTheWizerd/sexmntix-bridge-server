{
  "task": "sdk-permission-system-integration-design",
  "agent": "claude-sonnet-4-5",
  "date": "2025-11-13",
  "component": "permission-system-sdk-integration",

  "temporal_context": {
    "date_iso": "2025-11-13",
    "year": 2025,
    "month": 11,
    "week_number": 46,
    "quarter": "2025-Q4",
    "time_period": "recent"
  },

  "complexity": {
    "technical": "5: Requires mapping between two permission systems (SDK's canUseTool + allowedTools vs Semantix's PermissionWorkflowManager + SessionManager), understanding async permission flows, and designing clean integration without breaking existing UI",
    "business": "5: CRITICAL - Solves the fundamental permission leakage problem that has plagued the system. Enables true proactive permission control where session approvals don't leak to unintended operations.",
    "coordination": "4: Must integrate with existing PermissionWorkflowManager, SessionManager, UI permission dialogs, and maintain backward compatibility during migration"
  },

  "files_modified": "0",
  "files_touched": [],
  "tests_added": "0",
  "related_tasks": [
    "claude-agent-sdk-exploration-incomplete",
    "permission-leakage-investigation-incomplete",
    "scoped-bash-permission-leakage-fix"
  ],

  "outcomes": {
    "performance_impact": "No impact - design phase only",
    "test_coverage_delta": "0%",
    "technical_debt_reduced": "high-potential",
    "follow_up_needed": "true"
  },

  "summary": "Existing CLI permission system is reactive (parse permission_denials after CLI blocks) and leaks permissions (approving Write session gives unrestricted Bash) → SDK's canUseTool callback provides proactive permission control where we define allowed tools BEFORE API call and intercept permission requests in real-time",

  "root_cause": "The CLI-based approach forces reactive permission handling: we send tools to CLI, wait for permission_denials in response, then show dialog. This creates a timing gap where tools can execute before validation. The SDK's canUseTool callback pauses execution, waits for our decision, then continues - enabling true proactive control.",

  "solution": {
    "approach": "Map SDK's permission model to Semantix's existing permission system. Use canUseTool as the integration point to show permission UI. Translate session permissions from SessionManager into allowedTools array to skip dialogs for pre-approved operations. Handle permission denials by returning deny result instead of current reactive permission_denials parsing.",
    "key_changes": [
      "NO FILES MODIFIED YET - This is a design document for future implementation",
      "DESIGN: canUseTool callback will call PermissionWorkflowManager.requestPermission() to show UI dialog",
      "DESIGN: SessionManager.getApprovedTools(chatId) will populate SDK's allowedTools array",
      "DESIGN: Permission suggestions from SDK will map to SessionManager.storeSessionPermission() for 'don't ask again'",
      "DESIGN: ScopedToolBuilder will filter allowedTools based on operation type (Write session → only Write/Edit/MultiEdit + scoped Bash)"
    ]
  },

  "validation": "Successfully tested canUseTool callback in scripts/claude-sdk-test-permissions.ts. Confirmed: (1) Callback triggers when tool NOT in allowedTools, (2) Execution pauses waiting for callback, (3) Suggestions provided for 'don't ask again', (4) Can return allow/deny to control execution.",

  "gotchas": [
    {
      "issue": "CRITICAL MISUNDERSTANDING: allowedTools array PRE-APPROVES tools, bypassing all permission checks. Initial assumption was it defined available tools, but canUseTool would still be called.",
      "solution": "Understand the SDK permission model: allowedTools = skip permission check (auto-allow), canUseTool = only called for tools NOT in allowedTools, disallowedTools = hard block (never allow). This means we must carefully populate allowedTools only with truly pre-approved tools from SessionManager.",
      "category": "integration",
      "severity": "high"
    },
    {
      "issue": "canUseTool callback is async but blocks SDK execution - must not hang indefinitely waiting for user input",
      "solution": "Implement timeout in PermissionWorkflowManager if user doesn't respond. SDK provides AbortSignal in callback options - can listen for abort to cancel permission dialog if SDK times out.",
      "category": "integration",
      "severity": "medium"
    },
    {
      "issue": "SDK provides permission suggestions but format may not match our SessionManager's storage format",
      "solution": "Parse PermissionUpdate[] suggestions from SDK and translate to our session permission format. SDK suggestions include: addRules (with behavior and destination), which maps to our 'don't ask again' functionality.",
      "category": "integration",
      "severity": "medium"
    },
    {
      "issue": "Scoped Bash permissions: SDK treats 'Bash' as a single tool, but we need to scope by command type (write/delete/terminal)",
      "solution": "DO NOT include 'Bash' in allowedTools for Write/Delete sessions. Instead, intercept in canUseTool, parse bash command, validate against session permission, then return allow/deny. This maintains scoped validation while working with SDK's permission model.",
      "category": "architecture",
      "severity": "high"
    }
  ],

  "lesson": "The SDK's permission system is fundamentally different from our CLI approach. CLI = reactive (tools sent → permission_denials received → show dialog). SDK = proactive (define allowedTools → canUseTool intercepts → execution pauses → we decide). This architectural shift solves permission leakage: we never send 'Bash' to API in allowedTools unless we've validated the specific bash command. The key insight: allowedTools is not a list of available tools, it's a list of PRE-APPROVED tools that bypass checks.",

  "tags": [
    "permission-system",
    "canUseTool-callback",
    "allowedTools-array",
    "proactive-permissions",
    "permission-integration",
    "sdk-permission-model",
    "session-permissions",
    "scoped-bash-permissions",
    "dont-ask-again",
    "permission-workflow",
    "DESIGN-DOCUMENT"
  ],

  "code_context": {
    "key_patterns": [
      "canUseTool(toolName, input, options): Promise<PermissionResult> - SDK callback that pauses execution waiting for permission decision",
      "allowedTools: string[] - Tools that BYPASS permission checks (pre-approved, no callback triggered)",
      "disallowedTools: string[] - Tools that are FORBIDDEN (hard block, no callback triggered)",
      "PermissionResult: { behavior: 'allow', updatedInput, updatedPermissions? } | { behavior: 'deny', message, interrupt? }",
      "options.suggestions: PermissionUpdate[] - SDK's recommended permission rules for 'don't ask again' functionality",
      "options.signal: AbortSignal - Can listen for SDK timeout/cancellation"
    ],
    "api_surface": [
      "canUseTool(toolName: string, input: Record<string, unknown>, options: { signal: AbortSignal, suggestions?: PermissionUpdate[], toolUseID: string }): Promise<PermissionResult>",
      "PermissionResult = { behavior: 'allow', updatedInput: Record<string, unknown>, updatedPermissions?: PermissionUpdate[] } | { behavior: 'deny', message: string, interrupt?: boolean }",
      "PermissionUpdate = { type: 'addRules', rules: PermissionRuleValue[], behavior: PermissionBehavior, destination: PermissionUpdateDestination }",
      "PermissionBehavior = 'allow' | 'deny' | 'ask'",
      "PermissionUpdateDestination = 'userSettings' | 'projectSettings' | 'localSettings' | 'session'"
    ],
    "dependencies_added": [],
    "breaking_changes": []
  },

  "future_planning": {
    "next_logical_steps": [
      "STEP 1: Create PermissionBridge class that wraps canUseTool and calls PermissionWorkflowManager",
      "STEP 2: Implement SessionPermissionResolver.getApprovedTools(chatId): string[] to build allowedTools array",
      "STEP 3: Create ScopedBashValidator.validateInCanUseTool(command, sessionPermissions) for Bash scoping",
      "STEP 4: Implement PermissionSuggestionTranslator to convert SDK's PermissionUpdate[] to our session format",
      "STEP 5: Add timeout handling in PermissionWorkflowManager.requestPermission() with AbortSignal listening",
      "STEP 6: Test integration: approve Write session → next write command uses allowedTools (no dialog) → bash delete command triggers canUseTool (shows dialog)",
      "STEP 7: Test edge cases: user closes dialog (should deny), timeout (should deny), SDK aborts (should cleanup)"
    ],
    "architecture_decisions": {
      "permission-integration-point": "canUseTool is the PRIMARY integration point. PermissionWorkflowManager.requestPermission() will be called from canUseTool callback, showing the same UI dialogs we have today. This maintains UX consistency while gaining SDK benefits.",
      "allowedTools-population-strategy": "Populate allowedTools from SessionManager's approved tools EXCEPT: (1) Never include 'Bash' directly - validate in canUseTool instead, (2) Only include tools for current operation type (Write session → only Write/Edit/MultiEdit), (3) Update allowedTools when user approves new permissions mid-conversation",
      "scoped-bash-handling": "Bash is NEVER in allowedTools. Every bash command goes through canUseTool → ScopedBashValidator parses command → checks against session permissions → returns allow/deny. This is the ONLY way to maintain scoped validation with SDK's permission model.",
      "dont-ask-again-implementation": "When user checks 'don't ask again': (1) Apply SDK's suggestions via updatedPermissions in PermissionResult, (2) Store in SessionManager for current chat, (3) Add newly approved tool to allowedTools for future messages in same conversation (requires dynamic allowedTools updating)",
      "permission-denial-tracking": "SDK's result message includes permission_denials: SDKPermissionDenial[] with tool names and inputs. This replaces our reactive permission_denials parsing from CLI. We can show summary at end: 'X tools were blocked during this conversation'",
      "backward-compatibility": "During migration, keep PermissionWorkflowManager's public API unchanged. Add new method: handleSDKPermissionRequest(toolName, input, suggestions) that returns Promise<PermissionResult>. This allows gradual migration without breaking CLI provider."
    },
    "extension_points": [
      "src/ext/modules/logic-manager/permission/PermissionBridge.ts (NEW) - Wraps canUseTool and integrates with PermissionWorkflowManager",
      "src/ext/modules/logic-manager/permission/PermissionWorkflowManager.ts - Add handleSDKPermissionRequest() method for SDK integration",
      "src/ext/modules/logic-manager/permission/SessionPermissionResolver.ts (NEW) - Builds allowedTools array from SessionManager state",
      "src/ext/modules/logic-manager/permission/ScopedBashValidator.ts (NEW) - Validates bash commands in canUseTool callback",
      "src/ext/modules/logic-manager/permission/PermissionSuggestionTranslator.ts (NEW) - Converts SDK PermissionUpdate[] to session format"
    ]
  },

  "user_context": {
    "development_style": "design-first-then-implement",
    "naming_preferences": "technical-precise",
    "architecture_philosophy": "clean-integration-points",
    "quality_standards": "maintainability-focus"
  },

  "semantic_context": {
    "domain_concepts": [
      "proactive-vs-reactive-permissions",
      "pre-approved-tools",
      "permission-callback-interception",
      "scoped-tool-validation",
      "dont-ask-again-persistence",
      "permission-suggestion-mapping"
    ],
    "technical_patterns": [
      "async-callback-integration",
      "permission-bridge-pattern",
      "session-permission-resolution",
      "dynamic-allowlist-updating",
      "scoped-validator-interception"
    ],
    "integration_points": [
      "sdk-canUseTool-callback",
      "PermissionWorkflowManager",
      "SessionManager",
      "ScopedBashPermissionResolver",
      "permission-ui-dialogs"
    ]
  }
}
