{
  "task": "multi-tab-streaming-provider-isolation-fixes",
  "agent": "claude-sonnet-4-5",
  "date": "2025-01-16",
  "component": "multi-chat-architecture",

  "temporal_context": {
    "date_iso": "2025-01-16",
    "year": 2025,
    "month": 1,
    "week_number": 3,
    "quarter": "2025-Q1",
    "time_period": "recent"
  },

  "complexity": {
    "technical": "5: Multiple interconnected bugs in streaming architecture - stale DOM references, message filtering, provider state synchronization across UI and Extension",
    "business": "5: Critical bugs blocking multi-chat functionality - messages getting stuck, providers switching incorrectly between tabs, complete breakdown of multi-tab experience",
    "coordination": "4: Required coordinated fixes across streaming system, message routing, provider management, and UI-Extension communication bridge"
  },

  "files_modified": 7,
  "files_touched": [
    "src/ui/modules/ui-logic/ui-controllers/chat-controller/message-list/agent-messages-manager/dom/DOMReferences.js",
    "src/ui/modules/ui-logic/chat-tabs/chat-tab-manager/ChatSwitcher.js",
    "src/ui/modules/ui-logic/ui-controllers/chat-controller/message-list/MessageManagerRouter.js",
    "src/ui/modules/ui-logic/chat-tabs/chat-tab-manager/ChatStore.js",
    "src/ui/modules/ui-logic/providers/events/ProviderEventHandler.js",
    "src/ui/modules/ui-logic/providers/ProvidersUIManager.js",
    "src/ui/modules/ui-logic/chat-tabs/ChatTabManager.js",
    "src/ui/modules/ui-logic/ui-controllers/ui-controller-manager/UIControllerManager.js"
  ],
  "tests_added": 0,
  "related_tasks": [
    "multi-tab-css-visibility-architecture-implementation",
    "multi-chat-streaming-response-routing-fix",
    "multi-chat-instance-architecture"
  ],

  "outcomes": {
    "performance_impact": "Improved - no more DOM destruction on tab switches, messages stream to background tabs efficiently",
    "test_coverage_delta": "No change",
    "technical_debt_reduced": "high: Eliminated three critical architectural bugs, but identified one remaining sync issue needing fix",
    "follow_up_needed": "true: Provider sync between UI and Extension needs completion (detailed plan created)"
  },

  "summary": "Three critical multi-tab bugs: (1) Streaming element references going stale after tab switching, (2) Messages getting stuck when sent to background tabs, (3) Provider selection not isolated per chat → Fixed streaming reference selector bug, removed message filtering for background tabs, implemented per-chat provider storage, BUT discovered UI-Extension provider sync issue requiring event emission fix",

  "root_cause": "THREE ROOT CAUSES:\n\n1. STREAMING REFERENCE BUG: DOMReferences.refreshStreamingElement() was searching for '.streaming-container' class, but StreamInitializer creates elements with '.streaming-active' class - selector mismatch caused refreshStreamingElement() to always return false, leaving stale references\n\n2. MESSAGE FILTERING BUG: MessageManagerRouter was filtering ALL streaming events (CHAT_STREAM_START, CHAT_STREAM_CHUNK, CHAT_STREAM_COMPLETE, CHAT_STREAM_ERROR) by isForActiveChat() - any message for background tab was SKIPPED and LOST forever. Old architecture required this because single shared DOM couldn't handle multiple streams, but new per-chat DOM architecture makes filtering unnecessary and harmful\n\n3. PROVIDER ISOLATION BUG: ProviderStateManager was GLOBAL - when Tab B selected provider, it deactivated ALL other providers globally, changing Tab A's provider. Additionally, when ChatSwitcher restored provider on tab switch, it only updated UI state via setActiveProvider() but never emitted 'provider.switch.requested.v1' event to notify Extension, causing UI and Extension to be out of sync",

  "solution": {
    "approach": "Three-part fix: (1) Correct the querySelector class name to match actual DOM structure, (2) Remove message filtering to allow background tabs to receive messages into their dedicated DOMs, (3) Implement per-chat provider storage in ChatStore with save/restore logic during provider selection and tab switching, plus add event emission to notify Extension (planned but not yet implemented)",
    "key_changes": [
      "DOMReferences.js line 118: Changed querySelector from '.streaming-container' to '.streaming-active' - fixes selector mismatch with actual class created by StreamInitializer",
      "ChatSwitcher.js lines 82-108: Removed isStreaming condition check - now ALWAYS calls refreshStreamingElement() on every tab switch to handle streams started while tab was hidden",
      "MessageManagerRouter.js lines 80-97: Removed ALL isForActiveChat() filtering from streaming event handlers - messages now reach their target DOM regardless of active tab, CSS visibility controls what user sees",
      "ChatStore.js lines 20-42: Added providerId field to chat objects (line 33), create() method now accepts optional providerId parameter, added setProvider(chatId, providerId) and getProvider(chatId) methods (lines 150-167)",
      "ProviderEventHandler.js lines 68-80: Added ChatTabManager injection and save logic - when provider selected, saves to active chat via store.setProvider(activeChatId, provider)",
      "ProvidersUIManager.js lines 82-89: Added setChatTabManager() method to inject ChatTabManager into event handler for per-chat provider tracking",
      "ChatTabManager.js lines 40-46 & 121-133: Added ProvidersUIManager injection method and use current active provider when creating new chats via providersUIManager.getActiveProvider()",
      "ChatSwitcher.js lines 98-108: Added ProvidersUIManager injection and restore logic - when switching TO tab, restores that tab's saved provider via providersUIManager.setActiveProvider(newChat.providerId)",
      "UIControllerManager.js lines 117-133: Wired all provider-related dependencies - injected ChatTabManager into ProvidersUIManager, ProvidersUIManager into ChatTabManager and ChatSwitcher"
    ]
  },

  "validation": "Build successful after all changes. User testing confirmed: (1) Messages no longer get stuck - background tabs receive messages perfectly ✅, (2) Streaming works across tab switches - switch away and back, chunks appear ✅, (3) Provider icon changes correctly when switching tabs ✅, BUT (4) Extension still uses wrong provider - UI state changes but Extension not notified ❌ (requires event emission fix from detailed plan)",

  "gotchas": [
    {
      "issue": "Initial fix removing isStreaming condition wasn't enough - refreshStreamingElement() still returned false! Logs showed 'Streaming element refresh: none' even though element existed. Traced through code and discovered StreamInitializer.transformPlaceholder() adds '.streaming-active' class (line 73) and createStreamingElement() uses 'streaming-active' in className (line 82), but refreshStreamingElement() was searching for non-existent '.streaming-container' class",
      "solution": "Changed querySelector from '.streaming-container' to '.streaming-active' in DOMReferences.js line 118. Added improved logging to show success: 'logger.info([DOMReferences] ✅ Refreshed streaming element reference)'. This immediately fixed the stale reference issue",
      "category": "integration",
      "severity": "high"
    },
    {
      "issue": "After fixing streaming references, messages still getting stuck when sent from background tabs. User test: send message in Tab A, switch to Tab B before response arrives, response never appears in Tab A even when switching back. Logs showed 'Skipping event for chat default (active: chat-xxx)' - MessageManagerRouter was filtering out messages!",
      "solution": "Removed isForActiveChat() checks from ALL streaming event handlers in MessageManagerRouter.js lines 82-97. Changed from 'if (this.isForActiveChat(payload)) { route() }' to just 'route()'. Added comment explaining: 'Process ALL streaming events regardless of active tab - each chat has its own DOM, messages go to their tab even if hidden, CSS controls visibility'. This eliminated message loss completely",
      "category": "integration",
      "severity": "high"
    },
    {
      "issue": "Per-chat provider implementation complete and working (provider saved/restored correctly), but user reports 'the icon on the top do change providers between tab switch but the provider itself remain the last one you choose'. Logs showed '[ChatSwitcher] ✅ Restored provider: openai' but Extension kept using old provider. Root cause: ChatSwitcher calls providersUIManager.setActiveProvider() which only updates UI state (ProviderRegistry, icon), but does NOT emit 'provider.switch.requested.v1' event that Extension listens for!",
      "solution": "INCOMPLETE - Detailed plan created but not yet implemented. Need to: (1) Add eventBus parameter to ChatSwitcher constructor, (2) Emit 'provider.switch.requested.v1' event after calling setActiveProvider() in switchTo() method, (3) Wire eventBus from ChatTabManager to ChatSwitcher. This will notify Extension about provider changes during tab switching, same as when user clicks provider icon",
      "category": "integration",
      "severity": "high"
    },
    {
      "issue": "Architectural decision needed: Should chat/provider state be managed in Extension or UI? Initial recommendation was Extension as single source of truth, but Moti clarified: 'the rule is that the ui is dumb render module. chat store should be managed on the ui'",
      "solution": "Keep ChatStore in UI as source of truth for UI state (tabs, providers, messages). UI emits events to tell Extension what to do. Extension executes business logic (provider calls) based on events from UI. Clear separation: UI = state management + rendering, Extension = business logic execution. Per-chat provider stays in UI ChatStore, but UI must notify Extension via events",
      "category": "architecture",
      "severity": "medium"
    }
  ],

  "lesson": "In event-driven architectures with UI-Extension separation, programmatic state changes (like tab switching) must emit the SAME events as user interactions. When ChatSwitcher programmatically restores provider, it must emit 'provider.switch.requested.v1' just like ProviderIconManager does on user clicks. Otherwise UI and Extension get out of sync. The pattern: ANY state change that affects Extension behavior MUST emit corresponding event. Also: querySelector class names must match actual DOM structure - always verify what classes StreamInitializer/builders actually create, don't assume! Finally: In multi-tab architectures with per-chat DOMs, filtering messages by active tab is an anti-pattern from single-DOM era - let all messages reach their target DOMs, use CSS for visibility control",

  "tags": [
    "multi-chat",
    "streaming-bug-fix",
    "stale-references",
    "dom-selector-mismatch",
    "message-filtering",
    "background-tabs",
    "provider-isolation",
    "per-chat-state",
    "ui-extension-sync",
    "event-driven-architecture",
    "css-visibility",
    "INCOMPLETE",
    "event-emission-needed"
  ],

  "code_context": {
    "key_patterns": [
      "DOMReferences.refreshStreamingElement() - Queries for streaming element in active chat's message-list and updates currentStreamingElement reference",
      "MessageManagerRouter.isForActiveChat(payload) - Checks if message chatId matches activeChatId - REMOVED from streaming handlers to allow background tab messages",
      "ChatStore.setProvider(chatId, providerId) - Saves provider selection to specific chat for per-chat isolation",
      "ChatStore.getProvider(chatId) - Retrieves saved provider for specific chat",
      "ChatSwitcher.switchTo(chatId) - Orchestrates tab switching including provider restoration via providersUIManager.setActiveProvider()",
      "ProviderEventHandler.handleProviderSwitchRequest(payload) - Updates global provider state AND saves to active chat via store.setProvider()",
      "eventBus.emit('provider.switch.requested.v1', {provider, timestamp}) - Notifies Extension about provider change (MISSING in ChatSwitcher!)"
    ],
    "api_surface": [
      "DOMReferences.refreshStreamingElement(): boolean - Returns true if streaming element found and reference updated, false otherwise",
      "ChatStore.create(chatId: string, title: string, providerId?: string): Chat - Creates chat with optional initial provider",
      "ChatStore.setProvider(chatId: string, providerId: string): void - Updates chat's provider selection",
      "ChatStore.getProvider(chatId: string): string|null - Gets chat's saved provider",
      "ProvidersUIManager.setChatTabManager(chatTabManager: ChatTabManager): void - Injects dependency for per-chat provider tracking",
      "ChatTabManager.setProvidersUIManager(providersUIManager: ProvidersUIManager): void - Injects dependency for provider initialization on chat creation",
      "ChatSwitcher.setProvidersUIManager(providersUIManager: ProvidersUIManager): void - Injects dependency for provider restoration on tab switch",
      "ProviderEventHandler.setChatTabManager(chatTabManager: ChatTabManager): void - Injects dependency for saving provider to active chat"
    ],
    "dependencies_added": [],
    "breaking_changes": [
      "DOMReferences.refreshStreamingElement() - Changed querySelector from '.streaming-container' to '.streaming-active' (internal implementation, no external API change)",
      "MessageManagerRouter streaming event handlers - Removed isForActiveChat() filtering, now processes ALL events regardless of active tab (behavior change, but improves functionality)",
      "ChatStore.create() - Added optional third parameter providerId (backward compatible, defaults to null)",
      "ChatSwitcher constructor - FUTURE: Will add eventBus parameter (breaking change when implemented)"
    ]
  },

  "future_planning": {
    "next_logical_steps": [
      "CRITICAL: Implement provider sync fix from detailed plan - add eventBus to ChatSwitcher and emit 'provider.switch.requested.v1' event when restoring provider on tab switch (3 file changes: ChatSwitcher.js constructor + switchTo(), ChatTabManager.js pass eventBus)",
      "Add comprehensive logging to provider flow for debugging: '[Extension] Provider switched to: X' when Extension receives event",
      "Test edge cases: switch tabs rapidly during streaming, switch while provider selection is pending, create multiple tabs with different providers",
      "Consider: Should provider changes during active streaming be blocked or allowed? What happens if user switches provider mid-stream?",
      "Add visual indicator when background tab has new messages waiting (notification badge on tab)",
      "Optimize: Currently refreshStreamingElement() does querySelector every tab switch - could cache and only refresh when stream is active",
      "Document: Create architecture diagram showing UI ChatStore as source of truth, event-driven UI→Extension communication pattern"
    ],
    "architecture_decisions": {
      "ui_as_state_manager": "UI is 'dumb render module' but manages UI state (ChatStore). Extension executes business logic based on events from UI. Clear separation prevents tight coupling. Per-chat provider lives in UI ChatStore because it's UI state (what user selected), but Extension must be notified via events to execute with correct provider",
      "per_chat_dom_persistence": "Each chat gets dedicated .message-list DOM that persists forever (only hidden/shown with CSS). No innerHTML destruction means streaming references stay valid, event listeners survive, messages can arrive in background tabs. This is foundation for scalable multi-tab architecture",
      "remove_message_filtering": "Old single-DOM architecture required filtering messages by active tab. New per-chat DOM architecture makes filtering harmful - messages should always reach their target DOM regardless of visibility. CSS controls what user sees, not JavaScript filtering logic",
      "event_emission_symmetry": "Programmatic state changes (ChatSwitcher.switchTo) must emit SAME events as user interactions (ProviderIconManager.handleClick). This ensures UI and Extension stay synchronized. Pattern: if user action emits event, programmatic equivalent must too"
    },
    "extension_points": [
      "ChatStore - Add additional per-chat metadata: lastMessageTime, unreadCount, custom labels, starred status",
      "MessageListFactory - Could add animation support for tab transitions, lazy DOM creation (create on first switch), DOM cleanup after N inactive tabs",
      "ChatSwitcher - Could add 'beforeSwitch' and 'afterSwitch' hooks for plugins, cancel switch if conditions not met (e.g., unsaved input)",
      "ProviderEventHandler - Could add provider change confirmation dialog, block provider switch during active streaming, add provider-specific settings per chat",
      "DOMReferences - If performance issues arise, could cache querySelector results and invalidate on tab switch instead of querying every time"
    ]
  },

  "user_context": {
    "development_style": "staged-testing: Moti prefers implementing fixes, testing immediately, then moving to next issue. Uses logs extensively for debugging. Wants build after each logical change to verify no breakage",
    "naming_preferences": "natural-conversational: Moti uses conversational language ('messages are perfect', 'there still bug though'), appreciates clear emoji annotations in code and logs (✅ ❌ ⚠️)",
    "architecture_philosophy": "separation-of-concerns: Strong belief in 'UI is dumb render module' - UI manages UI state and rendering, Extension handles business logic. Event-driven communication between layers. Ultra-modular components with single responsibilities and dependency injection",
    "quality_standards": "fix-then-understand: When bugs occur, Moti wants logs to trace the issue, understand root cause before coding, then implement clean fix without backward compatibility junk. 'I pushed to github, worse case i restore' - prefers clean rewrites over patching"
  },

  "semantic_context": {
    "domain_concepts": [
      "multi-chat",
      "chat-tabs",
      "per-chat-state",
      "provider-selection",
      "session-continuity",
      "background-tabs",
      "streaming-responses",
      "message-routing",
      "ui-extension-bridge"
    ],
    "technical_patterns": [
      "per-chat-dom-isolation",
      "css-visibility-switching",
      "event-driven-architecture",
      "dependency-injection",
      "orchestrator-pattern",
      "factory-pattern",
      "querySelector-dom-selection",
      "state-synchronization-via-events"
    ],
    "integration_points": [
      "ChatStore",
      "MessageListFactory",
      "ChatSwitcher",
      "DOMReferences",
      "MessageManagerRouter",
      "ProvidersUIManager",
      "ProviderEventHandler",
      "OutgoingProcessor",
      "Extension-ChatInstanceManager"
    ]
  }
}
