{
  "task": "multi-tab-provider-id-propagation-failed-attempt",
  "agent": "claude-sonnet-4-5",
  "date": "2025-10-24",
  "component": "streaming-chunk-processor",

  "temporal_context": {
    "date_iso": "2025-10-24",
    "year": 2025,
    "month": 10,
    "week_number": 43,
    "quarter": "2025-Q4",
    "time_period": "recent"
  },

  "complexity": {
    "technical": "4: Multi-chat state isolation with streaming pipeline propagation across Extension-UI boundary",
    "business": "5: Critical bug - second tab with different provider completely fails to respond",
    "coordination": "3: Required understanding of ChatInstance lifecycle, placeholder system, and streaming chunk flow"
  },

  "files_modified": "4",
  "files_touched": [
    "src/ext/modules/logic-manager/message-router/streaming/chunk-processor/attachers/ProviderIdChunkAttacher.ts",
    "src/ext/modules/logic-manager/message-router/streaming/ChunkProcessor.ts",
    "src/ext/modules/logic-manager/message-router/streaming/chunk-processor/detectors/ProviderWorkingDetector.ts",
    "src/ext/modules/logic-manager/message-router/MessageRouter.ts"
  ],
  "tests_added": "0",
  "related_tasks": [
    "sessionid-multi-chat-continuation-fix-complete",
    "tab-id-duplication-waiting-for-id-fix",
    "multi-tab-streaming-provider-isolation-fixes"
  ],

  "outcomes": {
    "performance_impact": "CRITICAL FAILURE - Broke all chat functionality, even first tab stopped responding",
    "test_coverage_delta": "0%",
    "technical_debt_reduced": "none",
    "follow_up_needed": "true"
  },

  "summary": "FAILED ATTEMPT: Provider format breaking when switching providers between tabs (Tab 1: Claude, Tab 2: Codex) â†’ Attempted to propagate providerId through streaming chunks like sessionId, but broke the waiting_for_id placeholder system, causing complete system failure",

  "root_cause": "ProviderId was stored in ChatInstance per-chat but NOT propagated through streaming chunks. ChunkProcessor created once with providerManager.getActive()?.id (global state), causing all tabs to share same static providerId. When Tab 1 used Codex, providerId='codex'. When Tab 2 used Claude, ChunkProcessor still had providerId='codex' from construction time.",

  "solution": {
    "approach": "FAILED APPROACH: Mirror sessionId propagation pattern by creating ProviderIdChunkAttacher to dynamically retrieve providerId from ChatInstance and attach to chunk.provider field",
    "key_changes": [
      "ProviderIdChunkAttacher.ts: NEW component to retrieve providerId from ChatInstance using chatId and attach to chunk",
      "ChunkProcessor.ts: Added providerIdAttacher component, called attach() before provider detection",
      "ProviderWorkingDetector.ts: Changed to read providerId from chunk.provider instead of constructor parameter",
      "MessageRouter.ts: Removed global providerId injection, passed undefined to ChunkProcessor"
    ]
  },

  "validation": "Build succeeded with no TypeScript errors. HOWEVER, runtime testing revealed CRITICAL FAILURE - even first tab stopped responding after implementation.",

  "gotchas": [
    {
      "issue": "CRITICAL: ProviderIdChunkAttacher breaks waiting_for_id placeholder system. When user creates new chat, UI sends waiting_for_id as chatId. Attacher tries to find ChatInstance for waiting_for_id but it doesn't exist yet (ChatInstance only created AFTER first message processed by Extension). This causes chunk.provider to remain undefined, breaking ProviderWorkingDetector and entire streaming pipeline.",
      "solution": "ATTEMPTED FIX FAILED: Changed warn logs to debug, made it skip gracefully when ChatInstance doesn't exist. This still didn't work because the timing is fundamentally wrong - providerId needs to be available BEFORE streaming starts, but ChatInstance is created DURING streaming.",
      "category": "integration",
      "severity": "high"
    },
    {
      "issue": "ChatInstance lifecycle mismatch: ChatInstance is created by MessageRouter AFTER receiving first message, but streaming chunks flow immediately. The ProviderIdChunkAttacher runs during chunk processing, but ChatInstance may not exist yet for new chats.",
      "solution": "NO SOLUTION FOUND - This is a fundamental timing issue. Cannot attach providerId from ChatInstance if ChatInstance doesn't exist yet.",
      "category": "integration",
      "severity": "high"
    },
    {
      "issue": "ProviderWorkingDetector became dependent on chunk.provider being set, but for NEW chats (waiting_for_id), chunk.provider is undefined, causing detection to fail and breaking UI indicators.",
      "solution": "ATTEMPTED: Made ProviderWorkingDetector skip when no providerId. FAILED because this breaks first message detection entirely.",
      "category": "integration",
      "severity": "high"
    },
    {
      "issue": "Removed global providerId from ChunkProcessor constructor completely (passed undefined), removing the fallback that kept new chats working.",
      "solution": "SHOULD HAVE: Kept the global providerId as fallback for new chats, only override with per-chat providerId when ChatInstance exists. This hybrid approach wasn't attempted.",
      "category": "configuration",
      "severity": "high"
    }
  ],

  "lesson": "CRITICAL LESSON: Cannot blindly mirror sessionId pattern for providerId because they have DIFFERENT lifecycles. SessionId is EXTRACTED from provider response DURING streaming. ProviderId must be AVAILABLE BEFORE streaming starts. The sessionId pattern works because: (1) First chunk from provider contains session_id, (2) SessionIdChunkExtractor reads it from chunk and stores in ChatInstance. But providerId pattern fails because: (1) ProviderId must be known BEFORE sending to provider, (2) For new chats (waiting_for_id), ChatInstance doesn't exist yet, (3) Removing global providerId fallback breaks everything. A HYBRID APPROACH is needed: Use global providerId for new chats (waiting_for_id), use per-chat providerId from ChatInstance for existing chats.",

  "tags": [
    "FAILED-ATTEMPT",
    "multi-chat",
    "provider-isolation",
    "streaming-pipeline",
    "chatId",
    "waiting_for_id",
    "ChatInstance",
    "lifecycle-timing",
    "propagation-pattern",
    "CRITICAL-BUG",
    "provider-format",
    "DO-NOT-REPEAT"
  ],

  "code_context": {
    "key_patterns": [
      "SessionIdChunkExtractor.extract() - Extracts sessionId FROM provider response chunk and stores in ChatInstance",
      "ProviderIdChunkAttacher.attach() - FAILED PATTERN: Tries to retrieve providerId from ChatInstance and attach to chunk, but ChatInstance may not exist for new chats",
      "ChatInstanceManager.getInstance(chatId) - Returns ChatInstance or null if doesn't exist",
      "ChunkProcessor.processChunk() - Orchestrates chunk processing pipeline: sessionId extraction, providerId attachment, provider detection",
      "ProviderWorkingDetector.detect() - Detects when provider starts working, REQUIRES providerId to determine event type"
    ],
    "api_surface": [
      "ProviderIdChunkAttacher.attach(chunk: any): boolean - Returns true if providerId attached, false if skipped",
      "ChatInstance.getProviderId(): string | null - Returns stored providerId or null",
      "ProviderWorkingDetector.detect(chunk: any): boolean - Reads chunk.provider dynamically"
    ],
    "dependencies_added": [],
    "breaking_changes": [
      "ChunkProcessor constructor: providerId parameter changed from providerManager.getActive()?.id to undefined - BROKE new chat functionality",
      "ProviderWorkingDetector.detect(): Now requires chunk.provider to be set - BROKE new chat detection",
      "Chunk.provider field: Must be set by ProviderIdChunkAttacher - FAILS for waiting_for_id chats"
    ]
  },

  "future_planning": {
    "next_logical_steps": [
      "CORRECT APPROACH: Implement HYBRID providerId strategy - use global providerId for new chats (waiting_for_id placeholder), override with per-chat providerId from ChatInstance ONLY when ChatInstance exists and has providerId stored",
      "ALTERNATIVE APPROACH: Store providerId in UI's chatStore when provider selected, send providerId WITH first message so Extension knows which provider to use even before ChatInstance created",
      "INVESTIGATION NEEDED: Understand exactly WHEN ChatInstance is created relative to streaming start - does MessageRouter create it BEFORE calling handleStreaming or DURING?",
      "DEBUGGING: Add comprehensive logging to track ChatInstance lifecycle: when created, when providerId set, when first chunk processed",
      "TESTING: Create isolated test for new chat flow with waiting_for_id to verify ChatInstance timing"
    ],
    "architecture_decisions": {
      "why-mirror-sessionid-failed": "SessionId is EXTRACTED from provider response (pull pattern), ProviderId must be KNOWN before request (push pattern). Different directions require different propagation strategies.",
      "hybrid-approach-rationale": "Global providerId works for new chats where ChatInstance doesn't exist. Per-chat providerId needed for multi-tab isolation. Hybrid gives best of both: working new chats + isolated existing chats.",
      "fallback-importance": "Removing global providerId fallback was the critical mistake. Always maintain backward compatibility / fallback behavior when refactoring."
    },
    "extension_points": [
      "ChunkProcessor.buildComponents() - Where to add conditional providerId logic (global vs per-chat)",
      "ProviderWorkingDetector.detect() - Where to implement fallback: read chunk.provider first, fall back to constructor providerId if undefined",
      "MessageRouter constructor - Where global providerId should be maintained as fallback"
    ]
  },

  "user_context": {
    "development_style": "staged-testing-preferred-but-not-followed",
    "naming_preferences": "ultra-modular-architecture-with-descriptive-component-names",
    "architecture_philosophy": "single-responsibility-with-dependency-injection",
    "quality_standards": "zero-breaking-changes-backward-compatibility-critical"
  },

  "semantic_context": {
    "domain_concepts": [
      "multi-chat-isolation",
      "per-chat-state",
      "placeholder-chat-id-system",
      "waiting_for_id-pattern",
      "provider-format-detection",
      "streaming-chunk-pipeline",
      "ChatInstance-lifecycle"
    ],
    "technical_patterns": [
      "chunk-propagation-pattern",
      "extractor-vs-attacher-pattern",
      "pull-vs-push-data-flow",
      "global-fallback-strategy",
      "hybrid-state-resolution",
      "graceful-degradation-with-fallback"
    ],
    "integration_points": [
      "UI-Extension-boundary",
      "waiting_for_id-to-real-chatId-transition",
      "provider-selection-to-streaming-start",
      "ChatInstance-creation-timing",
      "chunk-processor-to-provider-detector-flow"
    ]
  }
}
